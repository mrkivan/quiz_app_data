{
  "total": 30,
  "items": [
    {
      "questionId": 1,
      "question": "Which function is used to prevent unnecessary recompositions by caching a value?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "remember caches a value across recompositions, preventing recalculation unless dependencies change.",
      "answerCellList": [
        {
          "answerId": 1,
          "questionId": 1,
          "data": "A. mutableStateOf",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 2,
          "questionId": 1,
          "data": "B. remember",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 3,
          "questionId": 1,
          "data": "C. LaunchedEffect",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 4,
          "questionId": 1,
          "data": "D. derivedStateOf",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 1,
        "answerId": [
          2
        ],
        "answer": [
          "B. remember"
        ],
        "explanation": "remember caches a value across recompositions, preventing recalculation unless dependencies change."
      }
    },
    {
      "questionId": 2,
      "question": "Which tool is used to profile recomposition in Jetpack Compose?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Layout Inspector provides insights into recomposition and UI hierarchy in Compose apps.",
      "answerCellList": [
        {
          "answerId": 5,
          "questionId": 2,
          "data": "A. Profiler",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 6,
          "questionId": 2,
          "data": "B. Layout Inspector",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 7,
          "questionId": 2,
          "data": "C. Logcat",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 8,
          "questionId": 2,
          "data": "D. Benchmark",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 2,
        "answerId": [
          6
        ],
        "answer": [
          "B. Layout Inspector"
        ],
        "explanation": "Layout Inspector provides insights into recomposition and UI hierarchy in Compose apps."
      }
    },
    {
      "questionId": 3,
      "question": "True or False: Recomposition occurs when a composable's state changes.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Recomposition is triggered when a composable's state or parameters change, causing it to redraw.",
      "answerCellList": [
        {
          "answerId": 9,
          "questionId": 3,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 10,
          "questionId": 3,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 3,
        "answerId": [
          9
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "Recomposition is triggered when a composable's state or parameters change, causing it to redraw."
      }
    },
    {
      "questionId": 4,
      "question": "Which of the following help optimize recomposition in Compose? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "remember, derivedStateOf, and stable data types reduce unnecessary recompositions, while mutableStateOf alone does not.",
      "answerCellList": [
        {
          "answerId": 11,
          "questionId": 4,
          "data": "A. remember",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 12,
          "questionId": 4,
          "data": "B. derivedStateOf",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 13,
          "questionId": 4,
          "data": "C. mutableStateOf",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 14,
          "questionId": 4,
          "data": "D. Stable data types",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 4,
        "answerId": [
          11,
          12,
          14
        ],
        "answer": [
          "A. remember",
          "B. derivedStateOf",
          "D. Stable data types"
        ],
        "explanation": "remember, derivedStateOf, and stable data types reduce unnecessary recompositions, while mutableStateOf alone does not."
      }
    },
    {
      "questionId": 5,
      "question": "Which function is used to run side effects in response to state changes?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "LaunchedEffect runs side effects when its keys change, optimizing performance by avoiding unnecessary executions.",
      "answerCellList": [
        {
          "answerId": 15,
          "questionId": 5,
          "data": "A. remember",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 16,
          "questionId": 5,
          "data": "B. LaunchedEffect",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 17,
          "questionId": 5,
          "data": "C. SideEffect",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 18,
          "questionId": 5,
          "data": "D. derivedStateOf",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 5,
        "answerId": [
          16
        ],
        "answer": [
          "B. LaunchedEffect"
        ],
        "explanation": "LaunchedEffect runs side effects when its keys change, optimizing performance by avoiding unnecessary executions."
      }
    },
    {
      "questionId": 6,
      "question": "True or False: Using lazy layouts like LazyColumn improves performance for large lists.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "LazyColumn renders only visible items, improving performance for large lists compared to regular Column.",
      "answerCellList": [
        {
          "answerId": 19,
          "questionId": 6,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 20,
          "questionId": 6,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 6,
        "answerId": [
          19
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "LazyColumn renders only visible items, improving performance for large lists compared to regular Column."
      }
    },
    {
      "questionId": 7,
      "question": "Which function creates a state derived from other states to avoid recomposition?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "derivedStateOf creates a state that updates only when its dependencies change, reducing recompositions.",
      "answerCellList": [
        {
          "answerId": 21,
          "questionId": 7,
          "data": "A. remember",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 22,
          "questionId": 7,
          "data": "B. derivedStateOf",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 23,
          "questionId": 7,
          "data": "C. mutableStateOf",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 24,
          "questionId": 7,
          "data": "D. LaunchedEffect",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 7,
        "answerId": [
          22
        ],
        "answer": [
          "B. derivedStateOf"
        ],
        "explanation": "derivedStateOf creates a state that updates only when its dependencies change, reducing recompositions."
      }
    },
    {
      "questionId": 8,
      "question": "Which of the following are best practices for optimizing Compose performance? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Using lazy layouts, stable data types, and minimizing state reads optimize performance, but frequent recomposition is not ideal.",
      "answerCellList": [
        {
          "answerId": 25,
          "questionId": 8,
          "data": "A. Use lazy layouts",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 26,
          "questionId": 8,
          "data": "B. Use stable data types",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 27,
          "questionId": 8,
          "data": "C. Trigger frequent recompositions",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 28,
          "questionId": 8,
          "data": "D. Minimize state reads",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 8,
        "answerId": [
          25,
          26,
          28
        ],
        "answer": [
          "A. Use lazy layouts",
          "B. Use stable data types",
          "D. Minimize state reads"
        ],
        "explanation": "Using lazy layouts, stable data types, and minimizing state reads optimize performance, but frequent recomposition is not ideal."
      }
    },
    {
      "questionId": 9,
      "question": "Which layout renders only visible items to improve performance?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "LazyColumn renders only visible items, reducing memory and CPU usage for large lists.",
      "answerCellList": [
        {
          "answerId": 29,
          "questionId": 9,
          "data": "A. Column",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 30,
          "questionId": 9,
          "data": "B. LazyColumn",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 31,
          "questionId": 9,
          "data": "C. Row",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 32,
          "questionId": 9,
          "data": "D. Box",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 9,
        "answerId": [
          30
        ],
        "answer": [
          "B. LazyColumn"
        ],
        "explanation": "LazyColumn renders only visible items, reducing memory and CPU usage for large lists."
      }
    },
    {
      "questionId": 10,
      "question": "True or False: Stable data types prevent unnecessary recompositions.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Stable data types, marked with @Stable or immutable, allow Compose to skip recompositions when unchanged.",
      "answerCellList": [
        {
          "answerId": 33,
          "questionId": 10,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 34,
          "questionId": 10,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 10,
        "answerId": [
          33
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "Stable data types, marked with @Stable or immutable, allow Compose to skip recompositions when unchanged."
      }
    },
    {
      "questionId": 11,
      "question": "Which function runs side effects on every recomposition?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "SideEffect runs on every recomposition, useful for non-lifecycle-aware operations, but should be used sparingly.",
      "answerCellList": [
        {
          "answerId": 35,
          "questionId": 11,
          "data": "A. LaunchedEffect",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 36,
          "questionId": 11,
          "data": "B. SideEffect",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 37,
          "questionId": 11,
          "data": "C. remember",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 38,
          "questionId": 11,
          "data": "D. derivedStateOf",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 11,
        "answerId": [
          36
        ],
        "answer": [
          "B. SideEffect"
        ],
        "explanation": "SideEffect runs on every recomposition, useful for non-lifecycle-aware operations, but should be used sparingly."
      }
    },
    {
      "questionId": 12,
      "question": "Which of the following can cause excessive recompositions? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Unstable data types, frequent state updates, and inline calculations can cause excessive recompositions, while lazy layouts reduce them.",
      "answerCellList": [
        {
          "answerId": 39,
          "questionId": 12,
          "data": "A. Unstable data types",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 40,
          "questionId": 12,
          "data": "B. Frequent state updates",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 41,
          "questionId": 12,
          "data": "C. Using lazy layouts",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 42,
          "questionId": 12,
          "data": "D. Inline calculations in composables",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 12,
        "answerId": [
          39,
          40,
          42
        ],
        "answer": [
          "A. Unstable data types",
          "B. Frequent state updates",
          "D. Inline calculations in composables"
        ],
        "explanation": "Unstable data types, frequent state updates, and inline calculations can cause excessive recompositions, while lazy layouts reduce them."
      }
    },
    {
      "questionId": 13,
      "question": "Which modifier can improve performance by deferring drawing?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "drawWithCache caches drawing operations, improving performance for complex graphics.",
      "answerCellList": [
        {
          "answerId": 43,
          "questionId": 13,
          "data": "A. drawWithContent",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 44,
          "questionId": 13,
          "data": "B. drawWithCache",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 45,
          "questionId": 13,
          "data": "C. clip",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 46,
          "questionId": 13,
          "data": "D. offset",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 13,
        "answerId": [
          44
        ],
        "answer": [
          "B. drawWithCache"
        ],
        "explanation": "drawWithCache caches drawing operations, improving performance for complex graphics."
      }
    },
    {
      "questionId": 14,
      "question": "True or False: Moving complex logic to ViewModel improves Compose performance.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Moving complex logic to ViewModel reduces composable workload, improving performance by minimizing recompositions.",
      "answerCellList": [
        {
          "answerId": 47,
          "questionId": 14,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 48,
          "questionId": 14,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 14,
        "answerId": [
          47
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "Moving complex logic to ViewModel reduces composable workload, improving performance by minimizing recompositions."
      }
    },
    {
      "questionId": 15,
      "question": "Which layout is used for lazy loading of grid items?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "LazyVerticalGrid renders only visible grid items, optimizing performance for large datasets.",
      "answerCellList": [
        {
          "answerId": 49,
          "questionId": 15,
          "data": "A. Grid",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 50,
          "questionId": 15,
          "data": "B. LazyVerticalGrid",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 51,
          "questionId": 15,
          "data": "C. Column",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 52,
          "questionId": 15,
          "data": "D. Row",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 15,
        "answerId": [
          50
        ],
        "answer": [
          "B. LazyVerticalGrid"
        ],
        "explanation": "LazyVerticalGrid renders only visible grid items, optimizing performance for large datasets."
      }
    },
    {
      "questionId": 16,
      "question": "Which of the following reduce memory usage in Compose? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Lazy layouts, image caching, and avoiding nested layouts reduce memory usage, while frequent state updates increase it.",
      "answerCellList": [
        {
          "answerId": 53,
          "questionId": 16,
          "data": "A. Using lazy layouts",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 54,
          "questionId": 16,
          "data": "B. Caching images",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 55,
          "questionId": 16,
          "data": "C. Frequent state updates",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 56,
          "questionId": 16,
          "data": "D. Avoiding nested layouts",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 16,
        "answerId": [
          53,
          54,
          56
        ],
        "answer": [
          "A. Using lazy layouts",
          "B. Caching images",
          "D. Avoiding nested layouts"
        ],
        "explanation": "Lazy layouts, image caching, and avoiding nested layouts reduce memory usage, while frequent state updates increase it."
      }
    },
    {
      "questionId": 17,
      "question": "Which annotation marks a data type as stable to optimize recomposition?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "@Stable indicates a data type's equality is predictable, allowing Compose to skip recompositions.",
      "answerCellList": [
        {
          "answerId": 57,
          "questionId": 17,
          "data": "A. @Immutable",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 58,
          "questionId": 17,
          "data": "B. @Stable",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 59,
          "questionId": 17,
          "data": "C. @Composable",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 60,
          "questionId": 17,
          "data": "D. @Model",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 17,
        "answerId": [
          58
        ],
        "answer": [
          "B. @Stable"
        ],
        "explanation": "@Stable indicates a data type's equality is predictable, allowing Compose to skip recompositions."
      }
    },
    {
      "questionId": 18,
      "question": "True or False: Inline composables can increase recomposition scope.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Inline composables can cause parent composables to recompose, increasing the recomposition scope.",
      "answerCellList": [
        {
          "answerId": 61,
          "questionId": 18,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 62,
          "questionId": 18,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 18,
        "answerId": [
          61
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "Inline composables can cause parent composables to recompose, increasing the recomposition scope."
      }
    },
    {
      "questionId": 19,
      "question": "Which tool measures frame rendering time in Compose?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The Android Studio Profiler measures frame rendering time, helping identify performance bottlenecks.",
      "answerCellList": [
        {
          "answerId": 63,
          "questionId": 19,
          "data": "A. Layout Inspector",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 64,
          "questionId": 19,
          "data": "B. Profiler",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 65,
          "questionId": 19,
          "data": "C. Logcat",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 66,
          "questionId": 19,
          "data": "D. Benchmark",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 19,
        "answerId": [
          64
        ],
        "answer": [
          "B. Profiler"
        ],
        "explanation": "The Android Studio Profiler measures frame rendering time, helping identify performance bottlenecks."
      }
    },
    {
      "questionId": 20,
      "question": "Which of the following improve rendering performance in Compose? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "drawWithCache, clipping, and hardware acceleration improve rendering, while frequent recompositions harm performance.",
      "answerCellList": [
        {
          "answerId": 67,
          "questionId": 20,
          "data": "A. Using drawWithCache",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 68,
          "questionId": 20,
          "data": "B. Applying clipping",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 69,
          "questionId": 20,
          "data": "C. Frequent recompositions",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 70,
          "questionId": 20,
          "data": "D. Using hardware acceleration",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 20,
        "answerId": [
          67,
          68,
          70
        ],
        "answer": [
          "A. Using drawWithCache",
          "B. Applying clipping",
          "D. Using hardware acceleration"
        ],
        "explanation": "drawWithCache, clipping, and hardware acceleration improve rendering, while frequent recompositions harm performance."
      }
    },
    {
      "questionId": 21,
      "question": "Which function is used to hoist state to avoid recomposition?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "State hoisting moves state to a higher composable or ViewModel, reducing recomposition scope.",
      "answerCellList": [
        {
          "answerId": 71,
          "questionId": 21,
          "data": "A. remember",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 72,
          "questionId": 21,
          "data": "B. State hoisting",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 73,
          "questionId": 21,
          "data": "C. LaunchedEffect",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 74,
          "questionId": 21,
          "data": "D. derivedStateOf",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 21,
        "answerId": [
          72
        ],
        "answer": [
          "B. State hoisting"
        ],
        "explanation": "State hoisting moves state to a higher composable or ViewModel, reducing recomposition scope."
      }
    },
    {
      "questionId": 22,
      "question": "True or False: Nested layouts can increase rendering overhead.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Nested layouts increase the complexity of the UI tree, leading to higher rendering overhead.",
      "answerCellList": [
        {
          "answerId": 75,
          "questionId": 22,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 76,
          "questionId": 22,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 22,
        "answerId": [
          75
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "Nested layouts increase the complexity of the UI tree, leading to higher rendering overhead."
      }
    },
    {
      "questionId": 23,
      "question": "Which modifier optimizes layout by skipping measurement when possible?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "wrapContentSize skips measurement for fixed-size content, improving layout performance.",
      "answerCellList": [
        {
          "answerId": 77,
          "questionId": 23,
          "data": "A. fillMaxSize",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 78,
          "questionId": 23,
          "data": "B. wrapContentSize",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 79,
          "questionId": 23,
          "data": "C. size",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 80,
          "questionId": 23,
          "data": "D. padding",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 23,
        "answerId": [
          78
        ],
        "answer": [
          "B. wrapContentSize"
        ],
        "explanation": "wrapContentSize skips measurement for fixed-size content, improving layout performance."
      }
    },
    {
      "questionId": 24,
      "question": "Which of the following are performance profiling tools for Compose? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Layout Inspector, Profiler, and Macrobenchmark help profile Compose performance, while Logcat is for logging.",
      "answerCellList": [
        {
          "answerId": 81,
          "questionId": 24,
          "data": "A. Layout Inspector",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 82,
          "questionId": 24,
          "data": "B. Profiler",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 83,
          "questionId": 24,
          "data": "C. Logcat",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 84,
          "questionId": 24,
          "data": "D. Macrobenchmark",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 24,
        "answerId": [
          81,
          82,
          84
        ],
        "answer": [
          "A. Layout Inspector",
          "B. Profiler",
          "D. Macrobenchmark"
        ],
        "explanation": "Layout Inspector, Profiler, and Macrobenchmark help profile Compose performance, while Logcat is for logging."
      }
    },
    {
      "questionId": 25,
      "question": "Which function is used to memoize expensive calculations?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "remember with keys memoizes calculations, recomputing only when keys change.",
      "answerCellList": [
        {
          "answerId": 85,
          "questionId": 25,
          "data": "A. mutableStateOf",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 86,
          "questionId": 25,
          "data": "B. remember",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 87,
          "questionId": 25,
          "data": "C. LaunchedEffect",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 88,
          "questionId": 25,
          "data": "D. SideEffect",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 25,
        "answerId": [
          86
        ],
        "answer": [
          "B. remember"
        ],
        "explanation": "remember with keys memoizes calculations, recomputing only when keys change."
      }
    },
    {
      "questionId": 26,
      "question": "True or False: Using @Immutable reduces recomposition overhead.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "@Immutable marks data as unchangeable, allowing Compose to skip recompositions for unchanged objects.",
      "answerCellList": [
        {
          "answerId": 89,
          "questionId": 26,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 90,
          "questionId": 26,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 26,
        "answerId": [
          89
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "@Immutable marks data as unchangeable, allowing Compose to skip recompositions for unchanged objects."
      }
    },
    {
      "questionId": 27,
      "question": "Which layout is best for horizontal scrolling lists?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "LazyRow renders only visible items in a horizontal list, optimizing performance.",
      "answerCellList": [
        {
          "answerId": 91,
          "questionId": 27,
          "data": "A. Row",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 92,
          "questionId": 27,
          "data": "B. LazyRow",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 93,
          "questionId": 27,
          "data": "C. Column",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 94,
          "questionId": 27,
          "data": "D. Box",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 27,
        "answerId": [
          92
        ],
        "answer": [
          "B. LazyRow"
        ],
        "explanation": "LazyRow renders only visible items in a horizontal list, optimizing performance."
      }
    },
    {
      "questionId": 28,
      "question": "Which of the following increase recomposition overhead? (Select all that apply)",
      "answerCellType": 1,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Complex inline logic, large composable trees, and unstable parameters increase recomposition, while stable data types reduce it.",
      "answerCellList": [
        {
          "answerId": 95,
          "questionId": 28,
          "data": "A. Complex inline logic",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 96,
          "questionId": 28,
          "data": "B. Large composable trees",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 97,
          "questionId": 28,
          "data": "C. Stable data types",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 98,
          "questionId": 28,
          "data": "D. Unstable parameters",
          "isItAnswer": true,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 28,
        "answerId": [
          95,
          96,
          98
        ],
        "answer": [
          "A. Complex inline logic",
          "B. Large composable trees",
          "D. Unstable parameters"
        ],
        "explanation": "Complex inline logic, large composable trees, and unstable parameters increase recomposition, while stable data types reduce it."
      }
    },
    {
      "questionId": 29,
      "question": "Which modifier optimizes scrolling performance for lists?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "nestedScroll enables smooth scrolling integration with lazy layouts, improving performance.",
      "answerCellList": [
        {
          "answerId": 99,
          "questionId": 29,
          "data": "A. scrollable",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 100,
          "questionId": 29,
          "data": "B. nestedScroll",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 101,
          "questionId": 29,
          "data": "C. flingBehavior",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 102,
          "questionId": 29,
          "data": "D. offset",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 29,
        "answerId": [
          100
        ],
        "answer": [
          "B. nestedScroll"
        ],
        "explanation": "nestedScroll enables smooth scrolling integration with lazy layouts, improving performance."
      }
    },
    {
      "questionId": 30,
      "question": "True or False: Using ViewModel for state management reduces recomposition overhead.",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "ViewModel manages state outside composables, reducing recomposition by centralizing state updates.",
      "answerCellList": [
        {
          "answerId": 103,
          "questionId": 30,
          "data": "A. True",
          "isItAnswer": true,
          "position": 1
        },
        {
          "answerId": 104,
          "questionId": 30,
          "data": "B. False",
          "isItAnswer": false,
          "position": 2
        }
      ],
      "correctAnswer": {
        "questionId": 30,
        "answerId": [
          103
        ],
        "answer": [
          "A. True"
        ],
        "explanation": "ViewModel manages state outside composables, reducing recomposition by centralizing state updates."
      }
    }
  ]
}