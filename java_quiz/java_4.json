{
  "total": 30,
  "items": [
    {
      "questionId": 1,
      "question": "What is the primary purpose of generics in Java?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Generics in Java provide type safety by allowing types to be parameterized, preventing runtime type errors.",
      "answerCellList": [
        {
          "answerId": 1,
          "questionId": 1,
          "data": "A. To increase runtime performance",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 2,
          "questionId": 1,
          "data": "B. To provide type safety",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 3,
          "questionId": 1,
          "data": "C. To enable multiple inheritance",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 4,
          "questionId": 1,
          "data": "D. To simplify exception handling",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 1,
        "answerId": [2],
        "answer": ["B. To provide type safety"],
        "explanation": "Generics in Java provide type safety by allowing types to be parameterized, preventing runtime type errors."
      }
    },
    {
      "questionId": 2,
      "question": "Which symbol is used to denote a generic type parameter in Java?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The angle brackets <> are used to denote generic type parameters in Java, such as <T>.",
      "answerCellList": [
        {
          "answerId": 5,
          "questionId": 2,
          "data": "A. []",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 6,
          "questionId": 2,
          "data": "B. <>",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 7,
          "questionId": 2,
          "data": "C. {}",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 8,
          "questionId": 2,
          "data": "D. ()",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 2,
        "answerId": [6],
        "answer": ["B. <>"],
        "explanation": "The angle brackets <> are used to denote generic type parameters in Java, such as <T>."
      }
    },
    {
      "questionId": 3,
      "question": "What is type erasure in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Type erasure removes generic type information at runtime, replacing type parameters with their bounds or Object.",
      "answerCellList": [
        {
          "answerId": 9,
          "questionId": 3,
          "data": "A. Converting types at runtime",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 10,
          "questionId": 3,
          "data": "B. Removing generic type information at runtime",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 11,
          "questionId": 3,
          "data": "C. Adding type constraints",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 12,
          "questionId": 3,
          "data": "D. Enabling dynamic typing",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 3,
        "answerId": [10],
        "answer": ["B. Removing generic type information at runtime"],
        "explanation": "Type erasure removes generic type information at runtime, replacing type parameters with their bounds or Object."
      }
    },
    {
      "questionId": 4,
      "question": "Which of the following is a valid generic class declaration?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "A valid generic class declaration uses angle brackets with a type parameter, like class MyClass<T>.",
      "answerCellList": [
        {
          "answerId": 13,
          "questionId": 4,
          "data": "A. class MyClass(T)",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 14,
          "questionId": 4,
          "data": "B. class MyClass<T>",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 15,
          "questionId": 4,
          "data": "C. class MyClass{T}",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 16,
          "questionId": 4,
          "data": "D. class MyClass[T]",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 4,
        "answerId": [14],
        "answer": ["B. class MyClass<T>"],
        "explanation": "A valid generic class declaration uses angle brackets with a type parameter, like class MyClass<T>."
      }
    },
    {
      "questionId": 5,
      "question": "What does the wildcard <?> represent in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The wildcard <?> represents an unknown type in Java generics, used when the specific type is not important.",
      "answerCellList": [
        {
          "answerId": 17,
          "questionId": 5,
          "data": "A. A specific type",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 18,
          "questionId": 5,
          "data": "B. An unknown type",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 19,
          "questionId": 5,
          "data": "C. A primitive type",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 20,
          "questionId": 5,
          "data": "D. A final type",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 5,
        "answerId": [18],
        "answer": ["B. An unknown type"],
        "explanation": "The wildcard <?> represents an unknown type in Java generics, used when the specific type is not important."
      }
    },
    {
      "questionId": 6,
      "question": "What is the purpose of the 'extends' keyword in a generic type bound?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The 'extends' keyword in generics restricts the type parameter to a specific class or interface or their subtypes.",
      "answerCellList": [
        {
          "answerId": 21,
          "questionId": 6,
          "data": "A. To allow any type",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 22,
          "questionId": 6,
          "data": "B. To restrict to a class or interface and its subtypes",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 23,
          "questionId": 6,
          "data": "C. To exclude subtypes",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 24,
          "questionId": 6,
          "data": "D. To enable primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 6,
        "answerId": [22],
        "answer": ["B. To restrict to a class or interface and its subtypes"],
        "explanation": "The 'extends' keyword in generics restricts the type parameter to a specific class or interface or their subtypes."
      }
    },
    {
      "questionId": 7,
      "question": "What does the wildcard <? extends Number> allow in a generic type?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The wildcard <? extends Number> allows any type that is a subtype of Number, such as Integer or Double.",
      "answerCellList": [
        {
          "answerId": 25,
          "questionId": 7,
          "data": "A. Only Number type",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 26,
          "questionId": 7,
          "data": "B. Any subtype of Number",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 27,
          "questionId": 7,
          "data": "C. Any supertype of Number",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 28,
          "questionId": 7,
          "data": "D. Only primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 7,
        "answerId": [26],
        "answer": ["B. Any subtype of Number"],
        "explanation": "The wildcard <? extends Number> allows any type that is a subtype of Number, such as Integer or Double."
      }
    },
    {
      "questionId": 8,
      "question": "What does the wildcard <? super Integer> allow in a generic type?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The wildcard <? super Integer> allows Integer or any of its supertypes, such as Number or Object.",
      "answerCellList": [
        {
          "answerId": 29,
          "questionId": 8,
          "data": "A. Only Integer type",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 30,
          "questionId": 8,
          "data": "B. Integer or any of its supertypes",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 31,
          "questionId": 8,
          "data": "C. Any subtype of Integer",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 32,
          "questionId": 8,
          "data": "D. Only primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 8,
        "answerId": [30],
        "answer": ["B. Integer or any of its supertypes"],
        "explanation": "The wildcard <? super Integer> allows Integer or any of its supertypes, such as Number or Object."
      }
    },
    {
      "questionId": 9,
      "question": "Since which Java version were generics introduced?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Generics were introduced in Java 5 to provide type safety and eliminate the need for casting.",
      "answerCellList": [
        {
          "answerId": 33,
          "questionId": 9,
          "data": "A. Java 4",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 34,
          "questionId": 9,
          "data": "B. Java 5",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 35,
          "questionId": 9,
          "data": "C. Java 6",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 36,
          "questionId": 9,
          "data": "D. Java 7",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 9,
        "answerId": [34],
        "answer": ["B. Java 5"],
        "explanation": "Generics were introduced in Java 5 to provide type safety and eliminate the need for casting."
      }
    },
    {
      "questionId": 10,
      "question": "Can primitive types be used as type parameters in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Primitive types cannot be used as type parameters in Java generics; only reference types are allowed.",
      "answerCellList": [
        {
          "answerId": 37,
          "questionId": 10,
          "data": "A. Yes",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 38,
          "questionId": 10,
          "data": "B. No",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 39,
          "questionId": 10,
          "data": "C. Only for arrays",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 40,
          "questionId": 10,
          "data": "D. Only for collections",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 10,
        "answerId": [38],
        "answer": ["B. No"],
        "explanation": "Primitive types cannot be used as type parameters in Java generics; only reference types are allowed."
      }
    },
    {
      "questionId": 11,
      "question": "What is a raw type in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "A raw type is a generic class or interface used without specifying a type parameter, like List instead of List<String>.",
      "answerCellList": [
        {
          "answerId": 41,
          "questionId": 11,
          "data": "A. A type with a specific parameter",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 42,
          "questionId": 11,
          "data": "B. A generic type without a type parameter",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 43,
          "questionId": 11,
          "data": "C. A primitive type",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 44,
          "questionId": 11,
          "data": "D. A final type",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 11,
        "answerId": [42],
        "answer": ["B. A generic type without a type parameter"],
        "explanation": "A raw type is a generic class or interface used without specifying a type parameter, like List instead of List<String>."
      }
    },
    {
      "questionId": 12,
      "question": "Why should raw types be avoided in modern Java code?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Raw types bypass type safety, leading to potential runtime errors like ClassCastException.",
      "answerCellList": [
        {
          "answerId": 45,
          "questionId": 12,
          "data": "A. They improve performance",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 46,
          "questionId": 12,
          "data": "B. They bypass type safety",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 47,
          "questionId": 12,
          "data": "C. They are deprecated",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 48,
          "questionId": 12,
          "data": "D. They prevent inheritance",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 12,
        "answerId": [46],
        "answer": ["B. They bypass type safety"],
        "explanation": "Raw types bypass type safety, leading to potential runtime errors like ClassCastException."
      }
    },
    {
      "questionId": 13,
      "question": "Which collection interface in Java uses generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The List interface in Java uses generics, such as List<String>, to ensure type safety.",
      "answerCellList": [
        {
          "answerId": 49,
          "questionId": 13,
          "data": "A. Runnable",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 50,
          "questionId": 13,
          "data": "B. List",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 51,
          "questionId": 13,
          "data": "C. Cloneable",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 52,
          "questionId": 13,
          "data": "D. Serializable",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 13,
        "answerId": [50],
        "answer": ["B. List"],
        "explanation": "The List interface in Java uses generics, such as List<String>, to ensure type safety."
      }
    },
    {
      "questionId": 14,
      "question": "What is a bounded type parameter in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "A bounded type parameter restricts the types that can be used as type arguments, using extends or super.",
      "answerCellList": [
        {
          "answerId": 53,
          "questionId": 14,
          "data": "A. A type parameter with no restrictions",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 54,
          "questionId": 14,
          "data": "B. A type parameter with restrictions",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 55,
          "questionId": 14,
          "data": "C. A primitive type parameter",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 56,
          "questionId": 14,
          "data": "D. A final type parameter",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 14,
        "answerId": [54],
        "answer": ["B. A type parameter with restrictions"],
        "explanation": "A bounded type parameter restricts the types that can be used as type arguments, using extends or super."
      }
    },
    {
      "questionId": 15,
      "question": "What is the syntax for a bounded type parameter using extends?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The syntax <T extends SuperClass> restricts T to be SuperClass or its subtypes.",
      "answerCellList": [
        {
          "answerId": 57,
          "questionId": 15,
          "data": "A. <T super SuperClass>",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 58,
          "questionId": 15,
          "data": "B. <T extends SuperClass>",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 59,
          "questionId": 15,
          "data": "C. <T implements SuperClass>",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 60,
          "questionId": 15,
          "data": "D. <T instanceof SuperClass>",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 15,
        "answerId": [58],
        "answer": ["B. <T extends SuperClass>"],
        "explanation": "The syntax <T extends SuperClass> restricts T to be SuperClass or its subtypes."
      }
    },
    {
      "questionId": 16,
      "question": "Can a generic class have multiple type parameters?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Yes, a generic class can have multiple type parameters, such as <T, U>.",
      "answerCellList": [
        {
          "answerId": 61,
          "questionId": 16,
          "data": "A. No",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 62,
          "questionId": 16,
          "data": "B. Yes",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 63,
          "questionId": 16,
          "data": "C. Only one type parameter",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 64,
          "questionId": 16,
          "data": "D. Only primitive type parameters",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 16,
        "answerId": [62],
        "answer": ["B. Yes"],
        "explanation": "Yes, a generic class can have multiple type parameters, such as <T, U>."
      }
    },
    {
      "questionId": 17,
      "question": "What is the diamond operator in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The diamond operator <> allows type inference in generic instance creation, introduced in Java 7.",
      "answerCellList": [
        {
          "answerId": 65,
          "questionId": 17,
          "data": "A. A type casting operator",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 66,
          "questionId": 17,
          "data": "B. A type inference operator",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 67,
          "questionId": 17,
          "data": "C. A wildcard operator",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 68,
          "questionId": 17,
          "data": "D. A type restriction operator",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 17,
        "answerId": [66],
        "answer": ["B. A type inference operator"],
        "explanation": "The diamond operator <> allows type inference in generic instance creation, introduced in Java 7."
      }
    },
    {
      "questionId": 18,
      "question": "What is an example of using the diamond operator?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "List<String> list = new ArrayList<>() uses the diamond operator to infer the type String.",
      "answerCellList": [
        {
          "answerId": 69,
          "questionId": 18,
          "data": "A. List<String> list = new ArrayList<String>()",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 70,
          "questionId": 18,
          "data": "B. List<String> list = new ArrayList<>()",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 71,
          "questionId": 18,
          "data": "C. List<String> list = new ArrayList<?>",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 72,
          "questionId": 18,
          "data": "D. List<String> list = new ArrayList[]",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 18,
        "answerId": [70],
        "answer": ["B. List<String> list = new ArrayList<>()"],
        "explanation": "List<String> list = new ArrayList<>() uses the diamond operator to infer the type String."
      }
    },
    {
      "questionId": 19,
      "question": "What is the purpose of the PECS principle in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "PECS (Producer Extends, Consumer Super) guides the use of wildcards to ensure type safety in generic collections.",
      "answerCellList": [
        {
          "answerId": 73,
          "questionId": 19,
          "data": "A. To define primitive types",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 74,
          "questionId": 19,
          "data": "B. To guide wildcard usage",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 75,
          "questionId": 19,
          "data": "C. To enforce type erasure",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 76,
          "questionId": 19,
          "data": "D. To allow multiple inheritance",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 19,
        "answerId": [74],
        "answer": ["B. To guide wildcard usage"],
        "explanation": "PECS (Producer Extends, Consumer Super) guides the use of wildcards to ensure type safety in generic collections."
      }
    },
    {
      "questionId": 20,
      "question": "According to PECS, when should <? extends T> be used?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "<? extends T> is used for a producer, where you only read from a generic collection.",
      "answerCellList": [
        {
          "answerId": 77,
          "questionId": 20,
          "data": "A. When writing to a collection",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 78,
          "questionId": 20,
          "data": "B. When reading from a collection",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 79,
          "questionId": 20,
          "data": "C. When both reading and writing",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 80,
          "questionId": 20,
          "data": "D. When defining a raw type",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 20,
        "answerId": [78],
        "answer": ["B. When reading from a collection"],
        "explanation": "<? extends T> is used for a producer, where you only read from a generic collection."
      }
    },
    {
      "questionId": 21,
      "question": "According to PECS, when should <? super T> be used?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "<? super T> is used for a consumer, where you only write to a generic collection.",
      "answerCellList": [
        {
          "answerId": 81,
          "questionId": 21,
          "data": "A. When reading from a collection",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 82,
          "questionId": 21,
          "data": "B. When writing to a collection",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 83,
          "questionId": 21,
          "data": "C. When both reading and writing",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 84,
          "questionId": 21,
          "data": "D. When defining a raw type",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 21,
        "answerId": [82],
        "answer": ["B. When writing to a collection"],
        "explanation": "<? super T> is used for a consumer, where you only write to a generic collection."
      }
    },
    {
      "questionId": 22,
      "question": "Can a generic method be declared in a non-generic class?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Yes, a generic method can be declared in a non-generic class using type parameters in the method signature.",
      "answerCellList": [
        {
          "answerId": 85,
          "questionId": 22,
          "data": "A. No",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 86,
          "questionId": 22,
          "data": "B. Yes",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 87,
          "questionId": 22,
          "data": "C. Only in generic classes",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 88,
          "questionId": 22,
          "data": "D. Only with primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 22,
        "answerId": [86],
        "answer": ["B. Yes"],
        "explanation": "Yes, a generic method can be declared in a non-generic class using type parameters in the method signature."
      }
    },
    {
      "questionId": 23,
      "question": "What is the syntax for a generic method?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "A generic method is declared with type parameters before the return type, like <T> T methodName().",
      "answerCellList": [
        {
          "answerId": 89,
          "questionId": 23,
          "data": "A. T methodName<T>()",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 90,
          "questionId": 23,
          "data": "B. <T> T methodName()",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 91,
          "questionId": 23,
          "data": "C. T <methodName>()",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 92,
          "questionId": 23,
          "data": "D. methodName<T>()",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 23,
        "answerId": [90],
        "answer": ["B. <T> T methodName()"],
        "explanation": "A generic method is declared with type parameters before the return type, like <T> T methodName()."
      }
    },
    {
      "questionId": 24,
      "question": "What happens if you try to add an element to a List<? extends Number>?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "You cannot add elements to a List<? extends Number> because it is read-only due to the upper-bound wildcard.",
      "answerCellList": [
        {
          "answerId": 93,
          "questionId": 24,
          "data": "A. It compiles and runs fine",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 94,
          "questionId": 24,
          "data": "B. It causes a compile-time error",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 95,
          "questionId": 24,
          "data": "C. It causes a runtime exception",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 96,
          "questionId": 24,
          "data": "D. It adds the element as Object",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 24,
        "answerId": [94],
        "answer": ["B. It causes a compile-time error"],
        "explanation": "You cannot add elements to a List<? extends Number> because it is read-only due to the upper-bound wildcard."
      }
    },
    {
      "questionId": 25,
      "question": "Can you add an Integer to a List<? super Number>?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Yes, you can add an Integer to a List<? super Number> because Integer is a subtype of Number.",
      "answerCellList": [
        {
          "answerId": 97,
          "questionId": 25,
          "data": "A. No",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 98,
          "questionId": 25,
          "data": "B. Yes",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 99,
          "questionId": 25,
          "data": "C. Only if the list is empty",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 100,
          "questionId": 25,
          "data": "D. Only if the list is of type Object",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 25,
        "answerId": [98],
        "answer": ["B. Yes"],
        "explanation": "Yes, you can add an Integer to a List<? super Number> because Integer is a subtype of Number."
      }
    },
    {
      "questionId": 26,
      "question": "What is a generic interface in Java?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "A generic interface is an interface that uses type parameters, like Comparable<T>.",
      "answerCellList": [
        {
          "answerId": 101,
          "questionId": 26,
          "data": "A. An interface with no methods",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 102,
          "questionId": 26,
          "data": "B. An interface with type parameters",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 103,
          "questionId": 26,
          "data": "C. An interface with static methods only",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 104,
          "questionId": 26,
          "data": "D. An interface with primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 26,
        "answerId": [102],
        "answer": ["B. An interface with type parameters"],
        "explanation": "A generic interface is an interface that uses type parameters, like Comparable<T>."
      }
    },
    {
      "questionId": 27,
      "question": "Which standard Java interface uses generics for comparison?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "The Comparable<T> interface uses generics to define a natural ordering for objects.",
      "answerCellList": [
        {
          "answerId": 105,
          "questionId": 27,
          "data": "A. Cloneable",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 106,
          "questionId": 27,
          "data": "B. Comparable<T>",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 107,
          "questionId": 27,
          "data": "C. Serializable",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 108,
          "questionId": 27,
          "data": "D. Runnable",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 27,
        "answerId": [106],
        "answer": ["B. Comparable<T>"],
        "explanation": "The Comparable<T> interface uses generics to define a natural ordering for objects."
      }
    },
    {
      "questionId": 28,
      "question": "What is type inference in Java generics?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Type inference allows the compiler to determine the type arguments for generics based on context, reducing explicit type declarations.",
      "answerCellList": [
        {
          "answerId": 109,
          "questionId": 28,
          "data": "A. Converting types at runtime",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 110,
          "questionId": 28,
          "data": "B. Determining type arguments by context",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 111,
          "questionId": 28,
          "data": "C. Enforcing type erasure",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 112,
          "questionId": 28,
          "data": "D. Allowing primitive types",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 28,
        "answerId": [110],
        "answer": ["B. Determining type arguments by context"],
        "explanation": "Type inference allows the compiler to determine the type arguments for generics based on context, reducing explicit type declarations."
      }
    },
    {
      "questionId": 29,
      "question": "Can a generic type parameter be used in a static context?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "No, generic type parameters are instance-based and cannot be used in static contexts like static methods or fields.",
      "answerCellList": [
        {
          "answerId": 113,
          "questionId": 29,
          "data": "A. Yes",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 114,
          "questionId": 29,
          "data": "B. No",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 115,
          "questionId": 29,
          "data": "C. Only in static methods",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 116,
          "questionId": 29,
          "data": "D. Only in static fields",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 29,
        "answerId": [114],
        "answer": ["B. No"],
        "explanation": "No, generic type parameters are instance-based and cannot be used in static contexts like static methods or fields."
      }
    },
    {
      "questionId": 30,
      "question": "What is the benefit of using generics in Java collections?",
      "answerCellType": 0,
      "selectedOptions": null,
      "answerSectionTitle": null,
      "explanation": "Generics in collections provide compile-time type checking and eliminate the need for casting when retrieving elements.",
      "answerCellList": [
        {
          "answerId": 117,
          "questionId": 30,
          "data": "A. Improved runtime performance",
          "isItAnswer": false,
          "position": 1
        },
        {
          "answerId": 118,
          "questionId": 30,
          "data": "B. Compile-time type checking and no casting",
          "isItAnswer": true,
          "position": 2
        },
        {
          "answerId": 119,
          "questionId": 30,
          "data": "C. Support for primitive types",
          "isItAnswer": false,
          "position": 3
        },
        {
          "answerId": 120,
          "questionId": 30,
          "data": "D. Automatic memory management",
          "isItAnswer": false,
          "position": 4
        }
      ],
      "correctAnswer": {
        "questionId": 30,
        "answerId": [118],
        "answer": ["B. Compile-time type checking and no casting"],
        "explanation": "Generics in collections provide compile-time type checking and eliminate the need for casting when retrieving elements."
      }
    }
  ]
}